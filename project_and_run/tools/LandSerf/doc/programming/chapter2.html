<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
 <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
 <link rel="Stylesheet" rev="Stylesheet" href="../css/landserf.css" media="All" />

<!-- LandSerf Header -->

 <title>LandSerf Programming Guide  - 2. Manipulating Raster Maps</title>
 <meta name="description" content="LandSerf Programming Guide" />
 <meta name="keywords" content="LandSerf, GIS, DEM, Java, programming, Terrain modelling" />
</head>

<body>
<div id="header">
 <a href="../../index.html">
  <img src="../images/landserfText.gif" width="304" height="57" alt="Go to LandSerf documentation" />
  <span id="lsicon">
   <img src="../images/iconTitle.gif" width="57" height="57" alt="Go to Landserf documentation" />
  </span>
 </a>
 <br />

 <div id="breadcrumbs">
  <span id="currentLocation">Chapter 2</span>       |
  <a href="index.html">Programming Guide</a> |
  <a href="../../index.html">LandSerf 2.3 Documentation</a> |
  <a href="http://www.landserf.org">landserf.org</a>
 </div>
</div>

<div id="container">

 <!-- End of header -->

<h1>Chapter 2. Manipulating Raster Maps</h1>

<div class="highlightbox">
By the end of this chapter you will be able to:
<br /><br />
<ul>
 <li>Create a raster map of arbitrary dimensions, resolution and location. <br /><br /></li>
 <li>Read individual cell values from a raster. <br /><br /></li>
 <li>Write individual cell values to a raster. <br /><br /></li>
 <li>Extract metadata from a raster. <br /><br /></li> 
 <li>Set the colour table for a raster.</li> 
</ul>
</div>
<div class="columnbreak"></div>


<h2>2.1 Creating Raster Maps</h2>

<p>
 As you will have seen in the <a href="./chapter1.html">previous chapter</a>, creating a new raster map
 is as straight forward as calling one of the <a href="api/jwo/landserf/structure/RasterMap.html" target="_new">
 <code>RasterMap</code></a> constructors. Each raster map will have a fixed number of rows and columns, some
 metadata (title, map projection, notes etc.), a location and resolution. Depending on how much of this information
 is known at compile-time, one of 7 different constructors can be called.
</p>


<div class="floatleft">
<img src="images/figure2.1.png" width="324" height="266" align="bottom" alt="Raster location, resolution and dimensions" />
<span class="caption">Example raster location, resolution and dimensions.</span>
</div>

<p>
 If you know the spatial properties of the raster you are about to create (location, x and y resolution and number of rows/columns),
 the most useful constructor is probably <code>RasterMap(int numRows, int numCols, Footprint fp)</code>. The 
 <a href="api/jwo/landserf/structure/Footprint.html" target="_new"><code>Footprint</code></a> class is a general one for
 storing the rectangular size and location of any spatial object. Its own constructor can take the coordinates of its
 bottom left corner, its width and height (see Chapter 5 of <a href="http://www.soi.city.ac.uk/jpss" target="_new">Java Programming for Spatial Sciences</a>
 for more details of this class). When used as part of the <code>RasterMap</code> constructor, this footprint is used to define
 the location and size of the bottom left pixel in the raster. Thus it defines both the location of the entire raster as well
 as its resolution. For example, to create a raster map with the properties shown in the figure to the left, you would call the
 following constructor: <br /><br />
 <code>new RasterMap(6,8, new Footprint(123,456,5,5)</code> 
 <br /><br />
 This implicitly sets the top-right location to (163,486) (8 columns of 5 units = 40 and 6 rows of 5 units = 30).
 </p>

<p>
 Note that the location set by the origin is of the <i>outer</i> boundary of the bottom-left raster cell. The centre of that cell
 would be equal to the origin plus half the resolution in x and y directions (125.5, 458.5 in this example).
</p>

<div class="columnbreak"></div>

<p>
 Other useful <code>RasterMap</code> constructors include two that take other spatial objects as arguments. <code>RasterMap(RasterMap oldRaster)</code>
 will create a new raster that is a copy (clone) of <code>oldRaster</code>. This can be useful if you wish to create a new raster map 
 that will have identical spatial properties to an existing one, but perhaps modified contents. In a similar way you can create a new
 raster map based on the spatial properties (but not contents) of a vector map (<code>RasterMap(VectorMap oldVectorMap)</code>).
</p>

<h2>2.2 Manipulating Raster Cells</h2>

<p>
 Reading and writing the contents of individual raster cells is very straightforward once you have created a <code>RasterMap</code>
 object. Cells can either be addressed by their row and column values (where row 0, column 0 is the top left cell), or by their absolute
 geographic location. Row/column manipulation is generally easier when the contents of an entire raster are to be processed and 
 geographic location more useful when location of individual cells are to be processed (for example as a result of user input).
</p>

<p>
 All raster values are store as <code>float</code> values and can therefore store any type of number with a precision of up to about
 7 decimal places. To set an arbitrary raster value use either
 <br /><br />
 <code>setAttribute(int row, int col, float newValue)</code> (row/column addressing)
 <br />or<br />
 <code>setAttribute(new Footprint(float easting, float northing), float newValue)</code> (geographic addressing)
</p>

<p>
 Likewise, raster values can be retrieved using equivalent 'get' methods:
 <br /><br />
 <code>float rasterValue = getAttribute(int row, int col)</code> (row/column addressing)
 <br />or<br />
 <code>float rasterValue = getAttribute(new Footprint(float easting, float northing))</code> (geographic addressing)
</p>
 

<h2>2.3 Handling Raster Metadata</h2>

<p>
 In common with other <a href="api/jwo/landserf/structure/SpatialObject.html" target="_new"><code>SpatialObject</code>s</a>,
 the boundary information and metadata associated with a <code>RasterMap</code> can be found easily using a number of 'get'
 methods. In particular, to retrieve the bounds of a raster (or any <code>SpatialObject</code>, the method <code>getBounds()</code>
 will return a <code>Footprint</code> representing the origin, width and height of the raster in geographic coordinates. Unlike
 other spatial objects, the number of rows and columns in a raster can also be retrieved by calling <code>getNumRows()</code> or
 <code>getNumColumns()</code>. The range of attribute values with a raster can be found with <code>getMinAttribute()</code>
 and <code>getMaxAttribute()</code>.
</p>

<p>
 Other non-spatial metadata can be retrieved using methods such as <code>getHeader()</code> (title, notes, owner information)
 and <code>getColourTable()</code>. Because these methods retrieve the metadata by reference, it is possible to edit metadata
 without calling the equivalent 'set' method. For example to change the title of <code>myRaster</code>, you could do the following:
 <br /><br />
 <code>myRaster.getHeader().setTitle(&quot;A new title&quot;);</code>
</p>

<p>
 Map projection information can also be retrieved and changed using <code>getProjection()</code> and <code>setProjection()</code>.
 The information itself is stored in the <a href="api/jwo/landserf/process/proj/Projection.html" target="_new"><code>Projection</code></a>
 class. Note however, that changing the map projection metadata does not itself change the projection of the raster. To reproject
 a spatial object you would need to call <a href="api/jwo/landserf/process/ProjectionThread.html" target="_new"><code>ProjectionThread</code></a>
 or provide your own reprojection code.
</p>

<h2>2.4 Examples</h2>

<p>
 The class below shows a simple example of manipulating a raster. It creates a new raster object of arbitrary dimensions
 and then allocates a random number between 0 and 100 to each cell in that raster. Finally it finds the range of values
 in that raster and allocates one of the preset colour tables stretched across that range.
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre>
</td>
<td valign="top">
<pre class="jSource">
<span class="jKeyword">import</span> jwo.landserf.structure.*;   <span class="jComment">// For spatial object class.</span>
<span class="jKeyword">import</span> jwo.landserf.process.io.*;  <span class="jComment">// For file handling.</span>

<span class="jComment">// **********************************************************</span>
<span class="jDocComment">/** Creates a simple raster map containing random values
  * values. Demonstrates how raster values can be written.
  * @author Jo Wood
  * @version 1.1, 15th October, 2007
  */</span>
<span class="jComment">// **********************************************************</span>

<span class="jKeyword">public</span> <span class="jKeyword">class</span> RandomSurface
{
    <span class="jComment">//------------------ Starter Method -----------------</span>
    
    <span class="jKeyword">public</span> <span class="jKeyword">static</span> <span class="jPrimitive">void</span> main(String[] args)
    {
        <span class="jKeyword">new</span> RandomSurface();
    }

    <span class="jComment">//------------------- Constructor -------------------</span>

    <span class="jKeyword">public</span> RandomSurface()
    {
        <span class="jComment">// Create a raster of 400 x 400 random cells with a 50 unit grid spacing</span>
        <span class="jComment">// and origin at (450000,280000)</span>
        RasterMap raster = <span class="jKeyword">new</span> RasterMap(400,400,<span class="jKeyword">new</span> Footprint(450000,280000,50,50));
        
        <span class="jKeyword">for</span> (<span class="jPrimitive">int</span> row=0; row&lt;raster.getNumRows();row++)
        {
            <span class="jKeyword">for</span> (<span class="jPrimitive">int</span> col=0; col&lt;raster.getNumCols();col++)
            {
                raster.setAttribute(row,col,(<span class="jPrimitive">float</span>)Math.random()*100);        
            }
        }
        
        <span class="jComment">// Add some simple metadata.</span>
        Header header = <span class="jKeyword">new</span> Header(&quot;<span class="jQuote">Random surface</span>&quot;);
        header.setNotes(&quot;<span class="jQuote">Uncorrelated random noise</span>&quot;);
        raster.setHeader(header);
        
        <span class="jComment">// Find range of values and create a colour table between them.</span>
        <span class="jPrimitive">float</span> min = raster.getMinAttribute();
        <span class="jPrimitive">float</span> max = raster.getMaxAttribute();
        raster.setColourTable(ColourTable.getPresetColourTable(ColourTable.IMHOF_L3,min,max));

        <span class="jComment">// Write new raster to file.</span>
        LandSerfIO.write(raster,&quot;<span class="jQuote">random.srf</span>&quot;);
    }
}
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->


<p>
 The raster produced by this code is shown below.
<br /><br />
 <img src="images/figure2.2.jpg" width="508" height="497" align="bottom" alt="Output from CreateRandomSurface()" />
 <span class="caption">Output from CreateRandomSurface() showing uncorrelated random noise and 'Imhof' colour scheme.</span>
</p>


<p>
 This second example creates another raster, but this time based on reading the values of an existing one. It first
 creates a clone of the raster stored in the file <code>random.srf</code> (produced by the code above). It then replaces
 each cell (except the first row and column) with the average of its neighbouring cells.
</p>


<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre>
</td>
<td valign="top">
<pre class="jSource">
<span class="jKeyword">import</span> jwo.landserf.structure.*;   <span class="jComment">// For spatial object class.</span>
<span class="jKeyword">import</span> jwo.landserf.process.io.*;  <span class="jComment">// For file handling.</span>

<span class="jComment">// **********************************************************</span>
<span class="jDocComment">/** Opens a raster map and smoothes its contents by averaging
  * local cells. Demonstrates how raster values can be read
  * and written.
  * @author Jo Wood
  * @version 1.1, 15th October, 2007
  */</span>
<span class="jComment">// **********************************************************</span>

<span class="jKeyword">public</span> <span class="jKeyword">class</span> SmoothSurface
{
    <span class="jComment">//------------------ Starter Method -----------------</span>
    
    <span class="jKeyword">public</span> <span class="jKeyword">static</span> <span class="jPrimitive">void</span> main(String[] args)
    {
        <span class="jKeyword">new</span> SmoothSurface();
    }

    <span class="jComment">//------------------- Constructor -------------------</span>

    <span class="jKeyword">public</span> SmoothSurface()
    {
        <span class="jComment">// Read in a raster from a file.</span>
        RasterMap raster = LandSerfIO.readRaster(&quot;<span class="jQuote">random.srf</span>&quot;);
        
        <span class="jKeyword">if</span> (raster == <span class="jKeyword">null</span>)       <span class="jComment">// Problem reading file</span>
        {
            System.err.println(&quot;<span class="jQuote">Problem reading raster</span>&quot;);
            System.exit(-1);
        }
        
        <span class="jComment">// Make a copy of the raster which will contain smoothed values.</span>
        RasterMap smoothedRaster = <span class="jKeyword">new</span> RasterMap(raster);
        
        <span class="jComment">// Smooth raster cells by taking average with cells to N and W.</span>
        <span class="jKeyword">for</span> (<span class="jPrimitive">int</span> row=1; row&lt;smoothedRaster.getNumRows();row++)
        {
            <span class="jKeyword">for</span> (<span class="jPrimitive">int</span> col=1; col&lt;smoothedRaster.getNumCols();col++)
            {
                smoothedRaster.setAttribute(row,col,(raster.getAttribute(row-1,col-1)+
                                                     raster.getAttribute(row,  col-1)+
                                                     raster.getAttribute(row,  col))/3);      
            }
        }
                
        <span class="jComment">// Add some simple metadata based on original raster.</span>
        Header header = <span class="jKeyword">new</span> Header(&quot;<span class="jQuote">Smoothed </span>&quot;+raster.getHeader().getTitle());
        header.setNotes(&quot;<span class="jQuote">Smoothed </span>&quot;+raster.getHeader().getNotes());
        smoothedRaster.setHeader(header);
        
        <span class="jComment">// Write new raster to file using non-factory method.</span>
        LandSerfIO.write(smoothedRaster,&quot;<span class="jQuote">smoothed.srf</span>&quot;);
    }
}
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>
 The raster produced by this code is shown below.
<br /><br />
 <img src="images/figure2.3.jpg" width="508" height="497" align="bottom" alt="Output from SmoothSurface()" />
 <span class="caption">Output from <code>SmoothSurface()</code> showing smoothed random noise and 'Imhof' colour scheme.</span>
</p>

<h3>2.5 Exercises</h3>

<ol>
 <li>
  Write a class that reads in two rasters of identical size and creates a new raster where each cell is based on the average
   of each pair of cells in the equivalent position in the two input rasters.
  <br /><br />
 </li>
 
 <li>
  Modify the class you have just written to allow rasters of possibly different sizes and locations to be combined in this way.
  The new raster should be the intersection of the two input rasters. Your program should display a warning if the two input
  rasters do not intersect at all. 
  <br /><br />
  <i>Hint:</i> You can use the method <code>getIntersectionMER()</code> to calculate the boundary of the intersecting region.
  You will also need to identify cells using absolute geographic referencing rather than row/column values.
 </li>
 
</ol>

 <!-- Footer area -->
 <div id="footer">
  <div id="lastModified">Last Modified, 20th April, 2009</div>
 </div>

</div> <!-- End of container area -->
</body>
</html>