<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
 <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
 <link rel="Stylesheet" rev="Stylesheet" href="../css/landserf.css" media="All" />

<!-- LandSerf Header -->

 <title>LandScript - Language Basics</title>
 <meta name="description" content="LandScript langauge basics" />
 <meta name="keywords" content="LandSerf, GIS, DEM, Java, scripting, map algebra, LandScript, programming, Terrain modelling" />
</head>

<body>
<div id="header">
 <a href="../../index.html">
  <img src="../images/landserfText.gif" width="304" height="57" alt="Go to LandSerf documentation" />
  <span id="lsicon">
   <img src="../images/iconTitle.gif" width="57" height="57" alt="Go to Landserf documentation" />
  </span>
 </a>
 <br />

 <div id="breadcrumbs">
  <span id="currentLocation">Language Basics</span>       |
  <a href="./index.html">LandScript</a> |
  <a href="../../index.html">LandSerf 2.3 Documentation</a> |
  <a href="http://www.landserf.org">landserf.org</a>
 </div>
</div>

<div id="container">

 <!-- End of header -->

<h1>LandScript - Language Basics</h1>

<h2>1. Language Syntax</h2>

<p>
 LandScript is made up of <i>commands</i> and <i>functions</i> that operate on <i>numbers</i>, <i>text</i> and <i>spatial objects</i>.
 The layout of script on the page is flexible and is designed to make reading script as easy as possible. Script can be spread over
 multiple lines with each instruction being terminated with a semicolon'<code>;</code>'.
</p>

<p>
 All non-blank lines in a script file will be interpreted by LandSerf's <i>script engine</i> except those that start with the
 hash symbol '<code>#</code>'. This symbol can be used to identify <i>comment lines</i> that help to explain the meaning of
 the script.
</p>

<p>
 So, for example, the two scripts shown below are treated in exactly the same way even though their layout and
 comments differ.
</p>
<table cellpadding="0" cellspacing="0">
<tr><td valign="top">
<pre class="numbering">
1
2
3
4
</pre>
</td>
<td valign="top">
<!-- ~~~~ Created using jFormat V2.3 ~~~~ -->
<pre class="jSource">
<span class="jComment"># Simple script to display a message on screen.</span>
<span class="jKeyword">version</span>(1.0);

<span class="jKeyword">echo</span>(&quot;<span class="jQuote">Hello world</span>&quot;);</pre>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
</td>

<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
</pre>
</td>

<td valign="top">
<!-- ~~~~ Created using jFormat V2.3 ~~~~ -->
<pre class="jSource">
<span class="jKeyword">version</span>(1.0);
<span class="jKeyword">echo</span>
<span class="jComment"># This is a comment line so it is ignored.</span>
  (&quot;<span class="jQuote">Hello world</span>&quot;);
<span class="jComment"># Layout is flexible, but each command line</span>
<span class="jComment"># must be terminated with a semicolon.</span></pre>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
</td></tr></table>

<p>
 LandScript is a case sensitive language, and by convention, all variables, functions and commands are given lower case
 letters (an exception is the intercapping of variable names described below).
</p>

<p>
 It is possible that commands, functions or even syntax may change in future versions of LandScript. It is therefore
 good practice to include the <code>version()</code> command at the start of a script. This will ensure that the 
 LandScript interpreter will always process the script in the way it was originally intended.
</p>


<h2>2. Variables</h2>

<p>
 Variables can be used to store items of information. There are 3 types of information that can be stored -
 <i>numbers</i>, <i>text</i> and <i>spatial objects</i>. LandScript is not a strictly typed language, which means
 that you do not need to declare what type of information is to be stored in a variable, and the type of information
 it does store can change while a script is running.
</p>

<p>
 Information is placed in variables using the assignment operator '<code>=</code>', where the code on the left
 of the <code>=</code> should be name of the variable to store the information, and the code on the right should
 be an expression that defines what is to be stored within it.
</p>

<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
</pre>
</td>
<td valign="top">
<!-- ~~~~ Created using jFormat V2.3 ~~~~ -->
<pre class="jSource">
<span class="jComment"># Script to show multiple variable types.</span>
<span class="jKeyword">version</span>(1.0);

message = &quot;<span class="jQuote">Hello World</span>&quot;;
<span class="jKeyword">echo</span>(message);

message = 1+2+3;
<span class="jKeyword">echo</span>(message);

myRaster = <span class="jKeyword">newraster</span>(0,0,10,10,100,100);</pre>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
</td></tr></table>

<p>
 In the example above, the variable <code>message</code> firstly stores a text string (&quot;<code>Hello World</code>&quot;).
 Text strings can be indicated with pairs of quotation marks (<code>&quot;</code>) surrounding the text. The next line in the
 example replaces the contents of the same variable with the result of evaluating the expression <code>1+2+3</code> (the
 number 6). Finally a separate variable <code>myRaster</code> is used to store an entire raster map created by the
 command <code><span class="jKeyword">newraster</span>()</code>.
</p>

<p>
 Variable names must start with alphabetic characters but can contain numbers (e.g. <code>answer1</code>, <code>map2006</code> etc.).
 They cannot contain spaces or non-alphanumeric characters. By convention, variable names should be lowercase except when they
 consist of compound words, in which case intercapping (capitalising of the first letter of subsequent words) is encouraged. For
 example <code>myRaster</code>, <code>forestMap</code>.
</p>

<p>
 Variables can also appear on the right hand side of the assignment operator, but only if they have been previously defined:
</p>

<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
</pre>
</td>
<td valign="top">
<!-- ~~~~ Created using jFormat V2.3 ~~~~ -->
<pre class="jSource">
<span class="jComment"># The following two lines are valid</span>
total = 0;
total = total+1;

<span class="jComment"># But the following would generate the error &quot;'newTotal' not found&quot;.</span>
newTotal = newTotal + 1;</pre>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
</td></tr></table>

<p>
 The <i>scope</i> of a variable describes the parts of code in which its contents can be read or changed. Scope
 is limited to the <i>block</i> of code in which it is first assigned. A block (see section 3 below), is usually
 defined as any code enclosed between braces <code>{</code> and <code>}</code> including any nested sub-blocks
 within it.
</p>

<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre>
</td>
<td valign="top">
<!-- ~~~~ Created using jFormat V2.3 ~~~~ -->
<pre class="jSource">
<span class="jComment"># var1 is first defined in the global block so is visible to the whole script.</span>
var1 = &quot;<span class="jQuote">Global variable</span>&quot;;

{
  <span class="jComment"># This is a sub-block so var2 is only visible within this block</span>
  <span class="jComment"># Note also that variables defined in the 'parent' block(s) of</span>
  <span class="jComment"># a sub-block are also visible.</span>
  var2 = &quot;<span class="jQuote">Local variable</span>&quot;;
  <span class="jKeyword">echo</span> (&quot;<span class="jQuote">Var1 is </span>&quot; &amp; var1 &amp; &quot;<span class="jQuote"> Var2 is </span>&quot; &amp; var2);
  
  <span class="jComment"># This will change the contents of the global variable originally defined outside this block.</span>
  var1 = &quot;<span class="jQuote">A new value</span>&quot;;
}

 <span class="jComment"># The following line would now generate an error since var2 is not visible.</span>
 <span class="jKeyword">echo</span> (&quot;<span class="jQuote">Var1 is </span>&quot; &amp; var1 &amp; &quot;<span class="jQuote"> Var2 is </span>&quot; &amp; var2);
</pre>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
</td></tr></table>

<p>
 Variables that are defined in the outermost block (as <code>var1</code> in the example above) are effectively
 global variables as their values can be read and changed in all parts of the script. The LandScript
 <i>ScriptEditor</i> identifies such global variables by colouring them mid-grey. It is generally good practice
 to make variables as local as possible within a script to avoid the possibility of accidentally changing variable 
 contents and to limit naming conflicts.
</p>
 

<h2>3. Expressions</h2>

<p>
 An <i>expression</i> is any collection of quantities (numbers, text or spatial objects) and operators that can
 be evaluated by the LandScript interpreter to produce a new quantity. The following are all examples of expressions:
</p>

<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
</pre>
</td>
<td valign="top">
<!-- ~~~~ Created using jFormat V2.3 ~~~~ -->
<pre class="jSource">
numeric1 = 1 + (2/3) * 4;
numeric2 = <span class="jKeyword">sin</span>(<span class="jKeyword">pi</span>()/3);
numeric3 = numeric1 + 2*numeric2;
text1    = &quot;<span class="jQuote">First pair. </span>&quot; &amp; &quot;<span class="jQuote">Second pair.</span>&quot;;
spatial1 = <span class="jKeyword">newraster</span>(5,5,15,15,100,100);
spatial1 = spatial1 + 5;</pre>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
</td>
<td valign="top">
<pre class="jSource">
<span class="jComment"># Evaluated as 3.6666666666666665 (note rounding error in last digit)</span>
<span class="jComment"># Evaluated as 0.8660254037844386</span>
<span class="jComment"># Evaluated as 5.398717474235544</span>
<span class="jComment"># Evaluated as the text 'First pair. Second pair.' (without quotes)</span>
<span class="jComment"># Evaluated as a raster of 100x100 cells each containing 0</span>
<span class="jComment"># Evaluated as a raster of 100x100 cells each containing 5</span> </pre></td>
</tr></table>


<h2>4. Loops and Program Control</h2>

<p>
 When LandScript code is interpreted, it is normally done line-by-line starting from the top of the script.
 However, it is possible to modify the flow of program control using <i>loops</i>, <i>conditional blocks</i>
 and the <code>return</code> command.
</p>

<h3>4.1 Loops</h3>
<p>
 Loops are created using the command <code><span class="jKeyword">while</span></code> followed by a <i>condition</i>
 in brackets and terminated by a semicolon. The <i>condition</i> can be any expression that can be evaluated to be
 true/non-zero or false/zero. The code to be repeated in the loop is then enclosed in braces following the
 <code>while</code> line. Because the looped code is defined in its own block, any variables defined for the first time
 inside the loop, are only visible within it.
</p>

<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
</pre>
</td>
<td valign="top">
<!-- ~~~~ Created using jFormat V2.3 ~~~~ -->
<pre class="jSource">
<span class="jKeyword">version</span>(1.0);

tableRow = 1;

<span class="jKeyword">while</span> (tableRow &lt;= 10);
{
  <span class="jKeyword">echo</span>(tableRow &amp; &quot;<span class="jQuote"> x 7 = </span>&quot; &amp; tableRow*7);
  tableRow = tableRow + 1;
}
</pre>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
</td>

<td valign="top">
<pre>
1 x 7 = 7
2 x 7 = 14
3 x 7 = 21
4 x 7 = 28
5 x 7 = 35
6 x 7 = 42
7 x 7 = 49
8 x 7 = 56
9 x 7 = 63
10 x 7 = 70
</pre>
</td></tr></table>

<p>
 The script above left generates times-table output shown to the right. You must take care to ensure that it is possible
 for the loop to terminate in a finite amount of time. In the example above this is ensured by adding 1 to the value of
 <code>tableRow</code> each time control loops round the code in braces.
</p>

<p>
 Note that if you are used to programming in languages such as C++ or Java, the <code><span class="jKeyword">while</span></code>
 line must always be terminated with a semicolon and the looped code itself must always be enclosed in braces even if it only
 contains a single line. Note also that there is no 'for' loop in LandScript. This can be represented instead with a 
 <code><span class="jKeyword">while</span></code> loop and a counter variable as shown in the times-table example above.
</p>

<h3>4.2 Conditional Blocks and the <code>return</code> statement</h3>

<p>
 A conditional block is identified with the <code><span class="jKeyword">if</span></code> keyword followed by a
 <i>condition</i> in brackets and terminated by a semicolon.  It works in much the same way as a while loop, except that
 the code within braces is only run once if the condition is evaluated to be true or non-zero. As with any block of script,
 the scope of any variables defined for the first time within a conditional block is limited to that block.
</p>

<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre>
</td>
<td valign="top">
<!-- ~~~~ Created using jFormat V2.3 ~~~~ -->
<pre class="jSource">
<span class="jComment"># Script to toss a coin.</span>
<span class="jKeyword">version</span>(1.0);

randomNum = <span class="jKeyword">rand</span>();

<span class="jKeyword">if</span> (randomNum &lt; 0.5);
{
   <span class="jKeyword">echo</span>(&quot;<span class="jQuote">Heads</span>&quot;);
}

<span class="jKeyword">if</span> (randomNum &gt;= 0.5);
{
   <span class="jKeyword">echo</span>(&quot;<span class="jQuote">Tails</span>&quot;);
}</pre>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
</td></tr></table>

<p>
 In the simple example above, two conditional blocks are used to simulate the outcome of a randomly
 tossed coin. Note that there is no 'else' construction in LandScript, so if mutually exclusive actions
 have to be modelled (as in the coin example above), you must explicitly state the mutually exclusive
 conditions.
</p>

<p>
 It is possible exit a script early using the <code><span class="jKeyword">return</span></code> keyword. When not used
 inside a script function (see section 5 below), calling <code><span class="jKeyword">return</span></code> will quit the
 script, so it is most likely to be used inside a conditional block. For example,
</p>

<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre>
</td>
<td valign="top">
<!-- ~~~~ Created using jFormat V2.3 ~~~~ -->
<pre class="jSource">
<span class="jComment"># Creates a raster containing the z scores of another raster.</span>
<span class="jKeyword">version</span>(1.0);

baseDir = &quot;<span class="jQuote">z:\data\testdata\</span>&quot;;
surf =<span class="jKeyword">open</span>(baseDir&amp;&quot;<span class="jQuote">nyquist.srf</span>&quot;);
zScores = <span class="jKeyword">new</span>(surf);

mean = <span class="jKeyword">info</span>(surf,&quot;<span class="jQuote">mean</span>&quot;);
stdev = <span class="jKeyword">info</span>(surf,&quot;<span class="jQuote">stdev</span>&quot;);

<span class="jKeyword">if</span> (stdev == 0);
{
  <span class="jKeyword">echo</span> (&quot;<span class="jQuote">Raster has no variation, so cannot calculate z-scores.</span>&quot;);
  <span class="jKeyword">return</span>;
}

zScores = (surf-mean)/stdev;

<span class="jKeyword">colouredit</span>(zScores,&quot;<span class="jQuote">diverging1</span>&quot;);
<span class="jKeyword">save</span>(zScores, baseDir&amp;&quot;<span class="jQuote">zScores.srf</span>&quot;);</pre>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
</td></tr></table>

<p>
 The conditional block from lines 11-15 first checks to see if there is any variation in the attribute values contained
 in the raster. If there is no variation (ie the standard deviation is zero), it reports an error message and exits the
 script at line 14. If there is some variation, control passes to line 17 and beyond.
</p>

<h2>5. Script Functions</h2>

<p>
 You can create your own functions (also known as methods or subroutines) in LandScript in order to group together
 the lines of code required to perform common tasks. User-defined functions should be indicated with the <code>function</code>
 keyword followed by the name of the function you wish to define and any parameters it requires. Following this line should be
 a block of code in braces that defines what the function actually does.
</p>

<p>
 Functions can optionally return a value that can be used by the main body of the script in further processing. If the value is
 numeric, this can be combined with other built in functions to form more complex expressions.
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
</pre>
</td>
<td valign="top">
<pre class="jSource">
<span class="jComment"># Script to show how a simple function works</span><i> </i>
<span class="jKeyword">version</span>(1.0);<i> </i>
<i> </i>
<span class="jKeyword">echo</span> (&quot;<span class="jQuote">The sum of the numbers is </span>&quot;&amp;sum(3,4));<i> </i>
<i> </i>
<span class="jComment"># Function to add two numbers together.</span><i> </i>
<span class="jComment"># Params: num1 First number to add.</span><i> </i>
<span class="jComment">#         num2 Second number to add.</span><i> </i>
<span class="jComment"># Return: Sum of the two given numbers.</span><i> </i>
<span class="jKeyword">function</span> sum(num1, num2)<i> </i>
{<i> </i>
    <span class="jKeyword">return</span> num1+num2;<i> </i>
}<i> </i>
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->


<p>
 Functions that do not return a value, but instead perform some specific task can also be useful, For example, the following
 displays the metadata associated with a raster map:
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre>
</td>
<td valign="top">
<pre class="jSource">
<span class="jComment"># Script to display the metadata associated with a raster.</span><i> </i>
<span class="jKeyword">version</span>(1.0);<i> </i>
<i> </i>
baseDir = &quot;<span class="jQuote">/data/testdata/</span>&quot;;<i> </i>
<i> </i>
newRaster = <span class="jKeyword">open</span>(baseDir &amp; &quot;<span class="jQuote">xslope.srf</span>&quot;);<i> </i>
ans = displayInfo (newRaster);<i> </i>
<i> </i>
<i> </i>
<span class="jComment"># Function to display raster metadata.</span><i> </i>
<span class="jComment"># Params: rast Raster whose metadata is to be reported.</span><i> </i>
<span class="jKeyword">function</span> displayInfo(rast)<i> </i>
{<i> </i>
  <span class="jKeyword">echo</span>(&quot;<span class="jQuote">Metadata for </span>&quot;&amp;<span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">title</span>&quot;));<i> </i>
<i> </i>
  <span class="jKeyword">echo</span>(&quot;<span class="jQuote">Bounds:</span>&quot;);<i> </i>
  <span class="jKeyword">echo</span>(&quot;<span class="jQuote">     </span>&quot;&amp;<span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">N</span>&quot;));<i> </i>
  <span class="jKeyword">echo</span>(<span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">W</span>&quot;)&amp;&quot;<span class="jQuote">  </span>&quot;&amp;<span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">E</span>&quot;));<i> </i>
  <span class="jKeyword">echo</span>(&quot;<span class="jQuote">     </span>&quot;&amp;<span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">S</span>&quot;));<i> </i>
  <span class="jKeyword">echo</span>(&quot;<span class="jQuote">Minimum: </span>&quot;&amp;<span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">min</span>&quot;)&amp;&quot;<span class="jQuote"> Maximum: </span>&quot;&amp;<span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">max</span>&quot;));<i> </i>
<i> </i>
  <span class="jKeyword">echo</span>(&quot;<span class="jQuote">Resolution - x: </span>&quot;&amp;<span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">xRes</span>&quot;)&amp;&quot;<span class="jQuote"> y: </span>&quot;&amp;<span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">yRes</span>&quot;));<i> </i>
  <span class="jKeyword">echo</span>(&quot;<span class="jQuote">Projection: </span>&quot;&amp;<span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">projection</span>&quot;));<i> </i>
  <span class="jKeyword">echo</span>(&quot;<span class="jQuote">Type: </span>&quot; &amp; <span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">type</span>&quot;));<i> </i>
  <span class="jKeyword">echo</span>(<span class="jKeyword">info</span>(rast,&quot;<span class="jQuote">notes</span>&quot;));<i> </i>
}<i> </i>
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>
 Functions can also recursively call themselves to provide very powerful processing constructs. In the example below, a simple
 recursive function calculates the factorial of any given number (the factorial of 6 is 6*5*4*3*2=720).
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre>
</td>
<td valign="top">
<pre class="jSource">
<span class="jComment"># Script to calculate factorials using a recursive function.</span><i> </i>
<span class="jKeyword">version</span>(1.0);<i> </i>
<i> </i>
number = 6;<i> </i>
answer = factorial(number);<i> </i>
<span class="jKeyword">echo</span> (&quot;<span class="jQuote">Factorial of </span>&quot; &amp; number &amp; &quot;<span class="jQuote"> is </span>&quot; &amp; answer);<i> </i>
<i> </i>
<span class="jComment"># Function that recursively calculates the given number's factorial.</span><i> </i>
<span class="jComment"># Params: num Number to calculate</span><i> </i>
<span class="jComment"># Return: The given number's factorial.</span><i> </i>
<span class="jKeyword">function</span> factorial(num)<i> </i>
{<i> </i>
    <span class="jKeyword">if</span> (num &lt;= 1);<i> </i>
    {<i> </i>
        <span class="jKeyword">return</span> 1;<i> </i>
    }<i> </i>
<i> </i>
    <span class="jKeyword">if</span> (num &gt; 1);<i> </i>
    {<i> </i>
        ans = factorial(num-1);<i> </i>
        <span class="jKeyword">return</span> ans*num; <i> </i>
    }<i> </i>
}<i> </i>
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>
 Note how line 20 inside the <code>factorial()</code> function recursively calls itself substituting <code>num-1</code> for the original
 value of <code>num</code>. Care should always be given when writing recursive functions that they always have a 'get-out clause' enabling
 control to be returned from the function. 
</p>

<h2>6. LandScript Programming Styles</h2>

<h3>6.1. LandScript as a Macro Language</h3>


<p>
 Probably the simplest approach to using LandScript is as a way of repeating a sequence of actions that would otherwise be achieved
 using menu selection in LandSerf. This has the advantage of be reproducable and sharable between users, although it does not take
 advantage of some of the more sophisticated functionality of the language.
</p>

<p>
 When used as a macro language, most of the LandScript code will be calls to the LandScript <a href="commands.html" target="_new">commands</a>
 providing the values that would otherwise be entered via the LandSerf Graphical User Interface. So for example, to load a file, change its
 projection and colour table and save a copy of the edited object, the following commands could be issued:
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre>
</td>
<td valign="top">
<pre class="jSource">
<span class="jComment"># Script to demonstrate simple macro processing.</span>
<span class="jKeyword">version</span>(1.0);

baseDir = &quot;<span class="jQuote">/data/testdata/</span>&quot;;

<span class="jComment"># Open file.</span>
rast = <span class="jKeyword">open</span>(baseDir&amp;&quot;<span class="jQuote">rast.srf</span>&quot;);

<span class="jComment"># Add projection metadata and reproject.</span>
<span class="jKeyword">edit</span>(rast,&quot;<span class="jQuote">projection</span>&quot;,&quot;<span class="jQuote">LatLong</span>&quot;);
<span class="jKeyword">edit</span>(rast,&quot;<span class="jQuote">ellipsoid</span>&quot;,&quot;<span class="jQuote">WGS 84</span>&quot;);
newRast = <span class="jKeyword">reproject</span>(rast,&quot;<span class="jQuote">UTM</span>&quot;,&quot;<span class="jQuote">true</span>&quot;,30,30);

<span class="jComment"># Provide new colour table</span>
<span class="jKeyword">colouredit</span>(newRast,&quot;<span class="jQuote">land3</span>&quot;);

<span class="jComment"># Save the new file.</span>
<span class="jKeyword">save</span>(newRast,baseDir&amp;&quot;<span class="jQuote">rastUTM.srf</span>&quot;);
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<h3>6.2. LandScript as a Map Algebra Calculator</h3>

<p>
 Map algebra is an attempt to formalise the way we can combine and process spatial data. The concept comes from the work of Dana
 Tomlin (Tomlin 1983, 1990) who proposed a platform independent way of recording spatial processing. The concept is a simple one:
 represent spatial objects as algebraic terms and allow those terms to be manipulated using mathematical and logical operators.
</p>

<p>
 For example, suppose we had two elevation models of the same area, one generated via remote sensing that represents the upper 
 surface of a region (which we will call <code>DSM</code>), the other generated via the interpolation of contours (which we will
 call <code>DGM</code>). The difference in height between these two models would give us the height of all the features, such as
 trees and hedges, that sit on top of DGM and have been recorded in the DSM. In map algebra terms, this can simply be represented as
</p>

<table border="0" cellspacing="0" cellpadding="4" >
<tr>
 <td><img src="images/figure1.1.gif" width="72" height="83" alt="Surface features" /></td>
 <td><b>=</b></td>
 <td><img src="images/figure1.2.gif" width="72" height="83" alt="DSM" /></td>
 <td><b>-</b></td>
 <td><img src="images/figure1.3.gif" width="72" height="83" alt="DGM" /></td>
</tr>
<tr>
 <td><b>Vegetation</b></td>
 <td><b>=</b></td>
 <td><b>DSM</b></td>
 <td><b>-</b></td>
 <td><b>DGM</b></td>
</tr>
</table>

<p>
 All map algebra operations can be expressed in the form
 <br /><br />
 <b>newObject = <i>f</i>([Object1], [Object2], [Object3]...)</b>
 <br /><br />
 In other words new spatial objects are created as a function of existing objects. These objects may be raster or vector maps.
 Depending on what is used as input to a map algebra operation, two broad categories of function can be considered.
</p>

<table border="0" cellspacing="0" cellpadding="4">
<tr>
<td valign="top"><img src="images/figure1.4.gif" width="300" height="116" alt="Local raster operations" /></td>
<td valign="top"><i>Local</i> operations usually take input from at least two spatial objects. The output for
any location is a function of the input objects at that same location. An example of a LandScript local operation
applied to a pair of raster maps might be:
<table><tr><td>
<pre class="jSource">
errorMap = <span class="jKeyword">sqrt</span>((dem1-dem2)^2);
</pre>
</td></tr></table>

which creates a raster containing the root of the squared difference between two elevation models for each raster cell.
</td>
</tr>

<tr>
 <td valign="top"><img src="images/localVect.png" width="300" height="122" alt="Local vector operations" /></td>
 <td valign="top">Applying local map algebra to vector maps works in a similar way except that the output map must first be created
     so that the vector objects that are to have new attributes may be defined. In other words, applying map algebra to
     vector objects has no effect on their <i>geometry</i>, but their <i>attributes</i> are a function of the input objects
     that share the same spatial location as the output objects. In LandScript, the centroid of each output object is used
     to define their locations.
     <br /><br />
     Both raster and vector maps may be combined in a single local map algebra expression. So for example, the following expression
     effecitvely creates a rasterized version of combined vector maps summing their contents where the vector maps overlap.
     <table cellpadding="0" cellspacing="0"><tr><td valign="top"><pre class="jSource">
raster = vect1 + vect2;
</pre></td></tr></table>

     </td>
</tr>

<tr>
<td valign="top"><img src="images/figure1.5.gif" width="300" height="156" alt="Focal operations" /></td>
<td valign="middle"><i>Focal</i> operations usually take input from several locations in a single spatial object. 
The output for any location is a function of the input object at points surrounding the output location. Such 
functions are often referred to as neighbourhood operations since they process the neighbourhood of location in 
order to generate output. LandScript can only apply focal operations to rasters and allows neighbouring raster cells
to be identified using a focal modifier in square brackets containing row and column offsets. For example:
<table cellpadding="0" cellspacing="0">
<tr><td valign="top">
<pre class="jSource">
smoothedDEM = (dem[-1,-1] + dem[-1,0] + dem[1,0] +
               dem[-1,0]  + dem[0,0]  + dem[1,0] + 
               dem[1,-1]  + dem[1,0]  + dem[1,1])/9;
</pre>
</td></tr></table>
creates a raster where each cell is the average of an input raster's immediate neighbourhood.
</td>
</tr>
</table>

<p>
 More sophisticated use of focal modifiers can be made by combining them with conditional operations. In the example
 below, the nested <code>ifselse</code> commands in lines 22-26 copy all the non-null raster cells from one raster map 
 to another as well as those that immediately border non-null cells. The result is a that islands are 'grown' by one
 cell. By using a local map algebra operation  (line 30) to find the difference between the original and expanded rasters,
 an additional 'coastline' map containing only the new border cells can be created. 
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre>
</td>
<td valign="top">
<pre class="jSource">
<span class="jComment"># Creates some fractal islands, then grows the coastlines by 1 pixel.</span><i> </i>
<span class="jKeyword">version</span>(1.0);<i> </i>
<i> </i>
baseDir = &quot;<span class="jQuote">/data/testdata/</span>&quot;;<i> </i>
<i> </i>
<span class="jComment"># Create empty raster.</span><i> </i>
fracSurf = <span class="jKeyword">newraster</span>(1000,1000,10,10,250,250,&quot;<span class="jQuote">Fractal</span>&quot;);<i> </i>
<i> </i>
<span class="jComment"># Fill raster with fractal surface.</span><i> </i>
<span class="jKeyword">fractal</span>(fracSurf,&quot;<span class="jQuote">2.01</span>&quot;);<i> </i>
islands = <span class="jKeyword">new</span>(fracSurf);<i> </i>
<i> </i>
<span class="jComment"># Use data range to get 'sea level';</span><i> </i>
maxi = <span class="jKeyword">info</span>(fracSurf,&quot;<span class="jQuote">max</span>&quot;);<i> </i>
mini = <span class="jKeyword">info</span>(fracSurf,&quot;<span class="jQuote">min</span>&quot;);<i> </i>
midPoint = mini + (maxi-mini)/2;<i> </i>
<i> </i>
<span class="jComment"># Flood all values below 'sea level'</span><i> </i>
fracSurf = <span class="jKeyword">ifelse</span>(fracSurf &lt; midPoint, null(), fracSurf);<i> </i>
<i> </i>
<span class="jComment"># Grow coastline</span><i> </i>
islands = <span class="jKeyword">ifelse</span>(fracSurf != null(), fracSurf,<i> </i>
             <span class="jKeyword">ifelse</span>(fracSurf[0,-1] != null(), fracSurf[0,-1],<i> </i>
                <span class="jKeyword">ifelse</span>(fracSurf[0,1] != null(),  fracSurf[0,1],<i> </i>
                   <span class="jKeyword">ifelse</span>(fracSurf[-1,0] != null(), fracSurf[-1,0],<i> </i>
                      <span class="jKeyword">ifelse</span>(fracSurf[1,0] != null(), fracSurf[1,0],null())))));<i> </i>
<i> </i>
<span class="jComment"># Find coastline by taking difference between original and grown islands.</span><i> </i>
coastline = <span class="jKeyword">new</span>(fracSurf);<i> </i>
coastline = islands-fracSurf;<i> </i>
<i> </i>
<span class="jComment"># Save original and expanded islands.</span><i> </i>
<span class="jKeyword">save</span>(islands,baseDir &amp; &quot;<span class="jQuote">islands.srf</span>&quot;);<i> </i>
<span class="jKeyword">save</span>(coastline,baseDir &amp; &quot;<span class="jQuote">coastline.srf</span>&quot;);<i> </i>
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>
 When creating a local map algebra expression, it is sometimes useful to be able to identify a complete spatial object
 rather than a particular cell value. This is especially so when including LandScript commands in an expression. For
 example, suppose we wished to add mean value of a raster to each cell in a raster. If we tried to do this with the
 following expression:
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
</pre>
</td>
<td valign="top">
<pre class="jSource">
dem = <span class="jKeyword">open</span>(&quot;<span class="jQuote">myRaster.srf</span>&quot;);

dem = dem + <span class="jKeyword">info</span>(dem,&quot;<span class="jQuote">mean</span>&quot;);
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>
 LandScript would generate the error: <b><code>Expecting spatial object as parameter 1 in info but number provided</code></b>.
 This is because second occurence of <code>dem</code> on the right hand side of the expression in line 3 is interpreted as being 
 part of a local operator that would take each cell in turn and process its numeric value. What we actually intended was for the
 <code>info()</code> command to treat that particular instance of <code>dem</code> as a single raster rather than process each of
 its cells. To force this to happen, simply place an underscore character (<code>_</code>) after the name of the raster:
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
</pre>
</td>
<td valign="top">
<pre class="jSource">
dem = <span class="jKeyword">open</span>(&quot;<span class="jQuote">myRaster.srf</span>&quot;);

dem = dem + <span class="jKeyword">info</span>(<b>dem_</b>,&quot;<span class="jQuote">mean</span>&quot;);
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>
 In this particular example, it would have been more efficient to store the mean of the <code>dem</code> values once in its
 own variable rather than calculate the same mean for every cell in the raster:
</p>
<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
</pre>
</td>
<td valign="top">
<pre class="jSource">
dem = <span class="jKeyword">open</span>(&quot;<span class="jQuote">myRaster.srf</span>&quot;);
mean = <span class="jKeyword">info</span>(dem,&quot;<span class="jQuote">mean</span>&quot;);
dem = dem + mean;
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ --> 
 
<p>
  Keeping code efficient in map algebra expressions is important if you wish your scripts to execute in a reasonable length of time.
  But there are some circumstances when the use of the underscore character to stop local map algebra operations being performed is
  necessary. For example, calling a LandScript command whose output is to replace one of the input parameters in that expression:
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
</pre>
</td>
<td valign="top">
<pre class="jSource">
raster = <span class="jKeyword">reproject</span>(raster_,&quot;<span class="jQuote">UTM</span>&quot;,&quot;<span class="jQuote">true</span>&quot;,50,50);
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>
 Without the underscore, LandScript would incorrectly interpret this expression as a local operator as it contains a spatial object
 variable (<code>raster</code>) on the left and right hand side of the equals symbol.
</p>

<p>
 Finally, the special variables <code>easting</code>, <code>northing</code>, <code>row</code> and <code>col</code> can be used
 in map algebra expressions to substitute the location coordinates of each cell in a spatial object into the expression itself.
 So in the example below, a mathematical function based on the (x,y) coordinates of each cell (line 7) is used to create a new surface: 
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre>
</td>
<td valign="top">
<pre class="jSource">
<span class="jComment"># Script to create a Nyquist sampling function.</span><i> </i>
<span class="jKeyword">version</span>(1.0);<i> </i>
<i> </i>
baseDir = &quot;<span class="jQuote">/data/testdata/</span>&quot;;<i> </i>
<i> </i>
nyquist = <span class="jKeyword">newraster</span>(-100,-100,1,1,201,201);<i> </i>
nyquist = 10* (<span class="jKeyword">sin</span>(<span class="jKeyword">easting</span>/10) / (<span class="jKeyword">easting</span>/10)) * (<span class="jKeyword">sin</span>(<span class="jKeyword">northing</span>/10) /(<span class="jKeyword">northing</span>/10));<i> </i>
<i> </i>
<span class="jComment"># Add metadata.</span><i> </i>
<span class="jKeyword">edit</span>(nyquist,&quot;<span class="jQuote">title</span>&quot;,&quot;<span class="jQuote">Nyquist</span>&quot;);<i> </i>
<span class="jKeyword">edit</span>(nyquist,&quot;<span class="jQuote">notes</span>&quot;,<i> </i>
             &quot;<span class="jQuote">Nyquist sampling model based on the 2-d sinC function </span>&quot;&amp;<i> </i>
             &quot;<span class="jQuote">((sin PI x / PI x)(sin PI y / PI y) )</span>&quot;); <i> </i>
<span class="jKeyword">edit</span>(nyquist,&quot;<span class="jQuote">type</span>&quot;,&quot;<span class="jQuote">elevation</span>&quot;);<i> </i>
<span class="jKeyword">colouredit</span>(nyquist,&quot;<span class="jQuote">land4</span>&quot;);<i> </i>
<i> </i>
<span class="jComment"># Save the new raster map.</span><i> </i>
<span class="jKeyword">save</span>(nyquist,baseDir&amp;&quot;<span class="jQuote">nyquist.srf</span>&quot;);<i> </i>
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

<p>
 <img src="images/nyquist.jpg" width="400" height="218" alt="Nyquist sampling function" /><br />
 <span class="caption">Nyquist sampling function produced by landscript.</span>
</p>

<h3>6.3. LandScript as a Lower Level Programming Language</h3>

<p>
 There may be some special cases where map algebra expressions do not provide sufficient control over operations to produce
 the desired output. In such circumstances, it is possible to use LandScript looping and conditional contructions with LandScript
 commands to process spatial objects in a low level fashion.
</p>

<p>
 The disadvantage of this approach is that it can be considerably slower than using map algebra, and certainly much slower than
 using the LandSerf API to code a routine in Java or some other low level language.
</p>


<p>
 Most lower level processing of a raster object will need to use two nested loops to select each raster cell in turn. The example
 below shows how this can be achieved in LandScript. Note that this particualar example simply does what would more readly be
 achieved with the single map algebra expression <code>newRast = rast1 + rast2;</code>
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre>
</td>
<td valign="top">
<pre class="jSource">
<span class="jComment"># Script to add the contents of two rasters.</span>
<span class="jKeyword">version</span>(1.0);

baseDir = &quot;<span class="jQuote">/Users/jwo/data/testData/</span>&quot;;

<span class="jComment"># Create the two input rasters and one output raster. </span>
rast1 = <span class="jKeyword">newraster</span>(0,0,1,1,100,100,&quot;<span class="jQuote">Fractal 1</span>&quot;); 
<span class="jKeyword">fractal</span>(rast1,&quot;<span class="jQuote">2.01</span>&quot;); 

rast2 = <span class="jKeyword">newraster</span>(0,0,1,1,100,100,&quot;<span class="jQuote">Fractal 2</span>&quot;); 
<span class="jKeyword">fractal</span>(rast2,&quot;<span class="jQuote">2.01</span>&quot;); 

newRast = <span class="jKeyword">new</span> (rast1);
<span class="jKeyword">edit</span>(newRast,&quot;<span class="jQuote">title</span>&quot;,&quot;<span class="jQuote">Sum of rast1 and rast2</span>&quot;);

<span class="jComment"># Store dimensions of the rasters</span>
numRows = <span class="jKeyword">info</span>(newRast,&quot;<span class="jQuote">numRows</span>&quot;);
numCols = <span class="jKeyword">info</span>(newRast,&quot;<span class="jQuote">numCols</span>&quot;);

<span class="jComment"># Process each raster cell individually.</span>
r=0;
<span class="jKeyword">while</span> (r &lt; numRows);
{
  c=0;
  <span class="jKeyword">while</span> (c &lt; numCols);
  {
    z1 = <span class="jKeyword">rvalueat</span>(rast1,r,c);
    z2 = <span class="jKeyword">rvalueat</span>(rast2,r,c);
    <span class="jKeyword">rvalueat</span>(newRast,r,c,z1+z2);
    c = c+1;
  }
  r = r +1;
}

<span class="jComment"># Save new raster.</span>
<span class="jKeyword">colouredit</span>(newRast,&quot;<span class="jQuote">grey1</span>&quot;);
<span class="jKeyword">save</span>(newRast,baseDir&amp;&quot;<span class="jQuote">newRast.srf</span>&quot;);
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->


<p>
 The key to being able to extract individual raster values is the landsript command <code>rvalueat()</code> which is able
 to extract the raster value at a given row and column coordinate (lines 27 and 28 above) as well as set a new raster value
 for a given cell (line 29 above). By calling this command inside two nested loops that process each column in the rasters
 row by row, all the raster cells may be processed.
</p>

<p>
 The code above is not particuarly useful in that is simply replicates the process more easily achieved with map algebra. However,
 for more sophisticated processing, such as recursive traversal of a raster, this approach can be useful:
</p>

<!-- ~~~~ Created using jFormat V2.4.1 ~~~~ -->
<table cellpadding="0" cellspacing="0"><tr>
<td valign="top">
<pre class="numbering">
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
</pre>
</td>
<td valign="top">
<pre class="jSource">
<span class="jComment"># Script to calculate flow magnitude of a DEM.</span>
<span class="jKeyword">version</span>(1.0);

basedir = &quot;<span class="jQuote">/data/testdata/</span>&quot;;

<span class="jComment"># Initialise flow magnitude and drainage basin rasters.</span>
dem = <span class="jKeyword">open</span>(baseDir&amp;&quot;<span class="jQuote">newRast.srf</span>&quot;);

aspect = <span class="jKeyword">surfparam</span>(dem,&quot;<span class="jQuote">aspect</span>&quot;,3);
flowMag = <span class="jKeyword">new</span>(dem);
basins = <span class="jKeyword">new</span>(dem);
basinID = 0;
<span class="jKeyword">edit</span>(flowMag,&quot;<span class="jQuote">title</span>&quot;,&quot;<span class="jQuote">Flow magnitude</span>&quot;);
<span class="jKeyword">edit</span>(flowMag,&quot;<span class="jQuote">type</span>&quot;,&quot;<span class="jQuote">other</span>&quot;);
<span class="jKeyword">edit</span>(basins,&quot;<span class="jQuote">title</span>&quot;,&quot;<span class="jQuote">Drainage basins</span>&quot;);
<span class="jKeyword">edit</span>(basins,&quot;<span class="jQuote">type</span>&quot;,&quot;<span class="jQuote">other</span>&quot;);

numRows = <span class="jKeyword">info</span>(dem,&quot;<span class="jQuote">numRows</span>&quot;);
numCols = <span class="jKeyword">info</span>(dem,&quot;<span class="jQuote">numCols</span>&quot;);
r=1;

<span class="jKeyword">while</span> (r &lt; numRows);
{
  <span class="jKeyword">echo</span>(&quot;<span class="jQuote">Processing row </span>&quot; &amp; r);
  c=1;
  <span class="jKeyword">while</span> (c &lt; numCols);
  {
    basinID = r*numCols+c;
    localFlow = calcFlowMag(r,c);
    <span class="jKeyword">rvalueat</span>(flowMag,r,c,localFlow);
    c = c +1;
  }
  r = r +1;
}

<span class="jComment"># Provide logarithmic colour scale for flow magnitude.</span>
<span class="jKeyword">colouredit</span>(flowMag,&quot;<span class="jQuote">exp1</span>&quot;);

<span class="jComment"># And a random colour table for drainage basins.</span>
<span class="jKeyword">colouredit</span>(basins,&quot;<span class="jQuote">random</span>&quot;);

<span class="jComment"># Save flow magnitude and drainage basins.</span>
<span class="jKeyword">save</span>(flowMag,baseDir&amp;&quot;<span class="jQuote">demFlowMag.srf</span>&quot;);
<span class="jKeyword">save</span>(basins,baseDir&amp;&quot;<span class="jQuote">demBasins.srf</span>&quot;);

endTime = <span class="jKeyword">datetime</span>();
<span class="jKeyword">echo</span> (&quot;<span class="jQuote">Completed in </span>&quot;&amp;(endTime-startTime)/10 &amp;&quot;<span class="jQuote">seconds.</span>&quot;);

<span class="jComment"># Recursive flow magnitude function.</span>
<span class="jKeyword">function</span> calcFlowMag(r,c)
{
  <span class="jComment"># Check we haven't been here before</span>
  visitedCell = <span class="jKeyword">rvalueat</span>(basins,r,c);
  <span class="jKeyword">if</span> (visitedCell == basinID);
  {
    <span class="jComment"># We have already visited this cell during this pass.</span>
    <span class="jKeyword">return</span> 0;
  }
  
  flow = 1;

  <span class="jComment"># Log this cell as belonging to the drainage basin.</span>
  <span class="jKeyword">rvalueat</span>(basins,r,c,basinID);

  <span class="jComment"># Stop if we have reached the edge.</span>
  <span class="jKeyword">if</span> ((r==0) <span class="jKeyword">or</span> (c == 0) <span class="jKeyword">or</span> (r &gt;= numRows-1) <span class="jKeyword">or</span> (c &gt;= numCols-1));
  {
    <span class="jKeyword">return</span> flow;
  }

  <span class="jComment"># Look for neighbours that might flow into this cell.</span>
  aspVal = <span class="jKeyword">rvalueat</span>(aspect,r-1,c);
  
  <span class="jKeyword">if</span> ((aspVal &gt;135) <span class="jKeyword">and</span> (aspVal &lt;=215));
  {
     fl = calcFlowMag(r-1,c);
     flow = flow +fl;
  }

  aspVal = <span class="jKeyword">rvalueat</span>(aspect,r+1,c);
  <span class="jKeyword">if</span> ((aspVal &gt;305) <span class="jKeyword">or</span> ((aspVal &lt;=45) <span class="jKeyword">and</span> (aspVal != null())));
  {
     fl = calcFlowMag(r+1,c);
     flow = flow +fl;
  }

  aspVal = <span class="jKeyword">rvalueat</span>(aspect,r,c-1);
  <span class="jKeyword">if</span> ((aspVal &gt;45) <span class="jKeyword">and</span> (aspVal &lt;= 135));
  {
     fl = calcFlowMag(r,c-1);
     flow = flow +fl;
  }

  aspVal = <span class="jKeyword">rvalueat</span>(aspect,r,c+1);
  <span class="jKeyword">if</span> ((aspVal &gt;215) <span class="jKeyword">and</span> (aspVal &lt;= 305));
  {
     fl = calcFlowMag(r,c+1);
     flow = flow +fl;
  }

  <span class="jKeyword">return</span> flow;
}
</pre>
</td></tr></table>
<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~ -->


<h2>References</h2>

 <p class="reference"><b>Brun, H.T. and Egenhofer, M.J.</b> (1997) <a href="http://www.spatial.maine.edu/~max/MapAlgebraSurvey.pdf" target="_new">User interfaces for map algebra.</a> <i>Journal of the Urban and Regional Information Systems Association, 9(1), pp.44-54</i> </p>
 <p class="reference"><b>Tomlin, C.D.</b> (1983) A map algebra. <i>Proceedings of the 1983 Harvard Computer Graphics Conference, Cambridge MA</i></p>
 <p class="reference"><b>Tomlin, C.D.</b> (1990) <i>Geographic Information Systems and Cartographic Modelling.</i> Englewood Cliffs, HJ: Prentice-Hall</p>


 <!-- Footer area -->
 <div id="footer">
  <div id="lastModified">Last Modified, 20th April, 2009</div>
 </div>

</div> <!-- End of container area -->
</body>
</html>